学习来源：
https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python
作者：
Roger Labbe（github）


# 第十二章：粒子滤波器

小知识点：

１：使用有限数量的随机采样点来计算结果称为蒙特卡洛（MC）方法

### Monte Carlo法使用

我们想求解𝜋的值，我们有边长为２的正方形，在该正方形中放入一个半径为１的圆，我们在这个正方形区域内随机生成20000个点，判断这些点在圆内有多少个（通过俩点之间距离公式），这些点占总体点的个数即为圆形面积（eg:有10000个点在圆内，则面积为４×（10000/20000） = 2）,然后使用圆形面积公式求解𝜋值

同样的已知PDF函数，求解某一段内的概率，也可以使用MC方法（判断点是否在给定一段长度内）

### 粒子滤波

1:在预测环节粒子云的位置发生改变，但权重没有变化（没有测量融入）

2：测量融入后不会改变粒子云位置，会调整粒子云权重。粒子距离传感器测量越近获得权重越大

３：检查有效粒子数量，如果过小则执行重采样以尝试确保我们的粒子能够很好地表示实际概率分布


### 粒子滤波器特性

![IMAGE ALT TEXT HERE](https://github.com/xdwgood/Navigation-and-control/blob/xdwgood-patch-1/156.png)

在kf中越小的测量方差，越有利于估计器工作，但过小的测量方差在使用粒子滤波器时候，却会造成有效粒子点过少，甚至传感器发散问题。这是因为随机生成的粒子点在较远位置几乎被放弃，剩下的在３个标准差内的点会大量重复。远离的点对均值的估计没有任何作用，并且在重采样后极可能被放弃。从本质上来说：因为很少有粒子会成为概率分布的良好样本（不能很好描述状态概率分布／非线性）

解决方案：

１：降低传感器可靠性，允许更多的粒子点被接受　　　　　

２：增大粒子云总体数量　　　　

３：合理选择处理化状态，得到更好的粒子云？尽可能在初始状态附近生成更多的点，但不要生成所有点，否则粒子无法描述系统的非线性

### 重要采样（Importance Sampling）

思考这个问题：我们如何从未知的概率分布中抽取样本？

**Importance Sampling**为我们提供了一种从不同的已知概率分布中提取样本并使用这些样本来计算未知样本的性质的方法。

算法思想：

我们从可能不正确的概率分布中提取了粒子，然后根据粒子与测量结果匹配的程度对它们进行加权。 该加权基于真实的概率分布，因此根据该理论得出的均值，方差等将是正确的！

具体数学说明如下：

假设我们想从未知概率分布函数𝜋(𝑥)进行采样（相当于机器人状态的概率分布），在假设我们已知概率分布函数𝑞(𝑥)（相当于我们的测量概率分布函数）

设ｆ（ｘ）为期望函数，推导如下：

![IMAGE ALT TEXT HERE](https://github.com/xdwgood/Navigation-and-control/blob/xdwgood-patch-1/157.png)

其中∫𝑓(𝑥)𝑞(𝑥)可计算， 我们定义𝜋(𝑥)/𝑞(𝑥)为权重，通常我们不知道这个值所以进行归一化处理，最后粒子平均值计算如下：

![IMAGE ALT TEXT HERE](https://github.com/xdwgood/Navigation-and-control/blob/xdwgood-patch-1/159.png)

### 系统重采样方法

重采样的目的：

让权重大的尽量多的出现，但也要保证有一定的点表示权重小的部分

![IMAGE ALT TEXT HERE](https://github.com/xdwgood/Navigation-and-control/blob/xdwgood-patch-1/158.png)

上图每个颜色块代表了事件权重，１：中重要权重没有被采样不重要的被多次采样（橙色部分多个黑点）　２：有大的权重没有被采样　３和４是被推荐的重采样方法
